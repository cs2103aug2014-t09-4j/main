//@author: a0116538a



	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\core\BakaTxt.java
	 */

    /**
     * This method checks if the flag to initiate the CLI for bakatxt is in the
     * arguments specified to the program in the terminal.
     *
     * note: this is a simple implementation. It would (probably) be much better
     *       to parse the flags properly for extensibility in the future. However,
     *       since there is only one flag that we actually even need, this solution
     *       is " Good Enoughâ„¢ ".
     *
     * @param args
     *        the String array we are checking
     * @return true if the array contains the flag to start the CLI
     */
     private static boolean isCLI (String[] args) {
         for (int i = 0; i < args.length; i++) {
             if (args[i].trim().equalsIgnoreCase(CLI)) {
                 return true;
             }
         }
         return false;
     }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\core\BakaTxt.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\BakaPanel.java
	 */


package bakatxt.gui;

import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.util.List;

import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import bakatxt.core.Task;
import bakatxt.gui.look.ThemeReader;
import bakatxt.gui.look.UIAnimator;
import bakatxt.gui.look.UIHelper;
import bakatxt.international.BakaTongue;

/**
 * This class is used as the actual window (i.e, what the user perceives as a window)
 * for BakaTXT. Apart from that, it also draws the input box and the rest of the content.
 *
 */
public class BakaPanel extends JPanel {
    /**
     * BakaTxt welcome message
     */
    private static final String MESSAGE_WELCOME = BakaTongue.getString("MESSAGE_WELCOME");

    private static Input _input;
    private static Contents _contents;
    private static BakaScrollPane _bakaScrollPane;
    private static FormattedText _alertMessage;

    public BakaPanel(List<Task> tasks) {

        _input = new Input();
        _contents = new Contents(tasks);
        _bakaScrollPane = new BakaScrollPane(_contents,
                _contents.getSize().height);
        _alertMessage = setAlertMessageText(MESSAGE_WELCOME);

        setOpaque(false);
        setMaximumSize(UIHelper.WINDOW_SIZE);
        setBackground(ThemeReader.getPanelColor());
        setLayout(new GridBagLayout());
        addComponentsToPane();
    }

    /**
     * @return the input box
     */
    public Input getInput() {
        return _input;
    }

    /**
     * set the text in the input box
     *
     * @param s
     *        is the string to be set
     */
    protected void setInputBoxText(String s) {
        _input.setText(s);
    }

    /**
     * set the text in the alert box
     *
     * @param s
     *        is the string to be set
     */
    protected void updateAlertMessageText(String s) {
        _alertMessage.setText(s);
    }

    /**
     * @return the scrollpane
     */
    public BakaScrollPane getScrollPane() {
        return _bakaScrollPane;
    }

    /**
     * This method refreshes what is displayed on the GUI
     *
     * @param tasks
     *        the tasks we are putting on the GUI
     */
    protected void refreshContents(List<Task> tasks) {

        setBackground(ThemeReader.getPanelColor());

        _input.setTheme();
        _alertMessage.setTheme(ThemeReader.getAlertTheme());

        _contents.removeAll();
        _contents.updateContents(tasks);

        _bakaScrollPane.setComponentSizeBasedOnHeight(_contents
                .getPreferredSize().height);
        _bakaScrollPane.revalidate();
        _bakaScrollPane.repaint();

        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                _bakaScrollPane.getVerticalScrollBar().setValue(0);
            }
        });

        repaint();
    }

    /**
     * This method dictates the area where the input box and the content is allowed
     * to be
     */
    private void addComponentsToPane() {
        GridBagConstraints layout = new GridBagConstraints();

        setInputBox(layout);
        setContent(layout);
        setAlertMessage(layout);
    }

    /**
     * Tell the GridBag where to draw the input box
     *
     * @param layout
     *        the GridBag which is being drawn on
     */
    private void setInputBox(GridBagConstraints layout) {
        layout.fill = GridBagConstraints.BOTH;
        layout.anchor = GridBagConstraints.FIRST_LINE_START;
        layout.weightx = 1.0;
        layout.weighty = 0.0;
        layout.gridx = 0;
        layout.gridy = 0;
        layout.insets = new Insets(2 * UIHelper.BORDER, 2 * UIHelper.BORDER,
                UIHelper.BORDER, 2 * UIHelper.BORDER);
        this.add(_input, layout);
    }

    /**
     * @param alertMessage
     *        the message to put in the layout specified
     */
    private void setAlertMessage(GridBagConstraints layout) {
        layout.fill = GridBagConstraints.NONE;
        layout.anchor = GridBagConstraints.PAGE_START;
        layout.weightx = 0.0;
        layout.weighty = 0.0;
        layout.gridx = 0;
        layout.gridy = 1;
        layout.gridheight = 1;
        layout.gridwidth = 1;
        this.add(_alertMessage, layout);
    }

    /**
     * Tell the GridBag where to draw the BakaScrollPane containing the content box
     *
     * @param layout
     *        is the GridBag which is being drawn on
     */
    private void setContent(GridBagConstraints layout) {
        layout.fill = GridBagConstraints.BOTH;
        layout.anchor = GridBagConstraints.FIRST_LINE_START;
        layout.weightx = 1.0;
        layout.weighty = 1.0;
        layout.gridx = 0;
        layout.gridy = 2;
        layout.insets = new Insets(0, 2 * UIHelper.BORDER, 2 * UIHelper.BORDER,
                2 * UIHelper.BORDER);
        this.add(_bakaScrollPane, layout);
    }

    /**
     * @param message
     *        is the string to style
     * @return a alert message FormattedText with the string
     */
    private static FormattedText setAlertMessageText(String message) {
        return new FormattedText(message, ThemeReader.getAlertTheme());
    }

    /**
     * Shake the input box when an error in input is detected, flash it if it is
     * successful
     *
     * @param isSuccessful
     *        is the boolean that decides whether or not to shake the box or flash it
     */
    protected void animateInputBox(final boolean isSuccessful) {
        Runnable r = new Runnable() {
            @Override
            public void run() {
                final UIAnimator animate = new UIAnimator(_input);
                if (isSuccessful) {
                    animate.flashComponent();
                } else {
                    animate.shakeComponent();
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
    }

    /**
     * Make the corners of the BakaPanel round
     */
    @Override
    protected void paintComponent(Graphics g) {
        UIHelper.paintRoundedRectangle(g, getBackground(), getWidth(),
                getHeight());
        super.paintComponent(g);
    }
}
	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\BakaPanel.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\BakaScrollPane.java
	 */


package bakatxt.gui;

import java.awt.Container;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneLayout;
import javax.swing.Timer;
import javax.swing.plaf.basic.BasicScrollBarUI;

import bakatxt.gui.look.ThemeReader;
import bakatxt.gui.look.UIHelper;

/**
 * This class gives an invisible vertical scrollbar to a component when it's
 * maximum height is reached
 *
 */
public class BakaScrollPane extends JScrollPane {

    private static final int WIDTH = UIHelper.WINDOW_X - 4 * UIHelper.BORDER;
    private static final int BAR_WIDTH = 9;
    private static final int BAR_ROUNDNESS = 9;
    private static final int VANISH_TIMER = 1000;

    private Timer _timer;

    public BakaScrollPane(JComponent component, int initialHeight) {
        super(component);
        component.setAutoscrolls(true);
        setComponentSizeBasedOnHeight(initialHeight);
        setViewportView(component);
        setInvisiblePane();
        setScrollBars();
        setComponentZOrder(getViewport(), 1);
        setViewBox();
        setTimeout();
    }

    /**
     * @param height is to be the height of the BakaScrollPane
     */
    protected void setComponentSizeBasedOnHeight(int height) {

        assert (height >= 0) : "height of pane must not be less than zero";

        if (height > UIHelper.WINDOW_Y) {
            height = UIHelper.WINDOW_Y;
        }
        this.setPreferredSize(new Dimension(WIDTH, height));
    }

    /**
     * Make the background of the pane invisible as well as the borders to be
     * non-existent
     */
    private void setInvisiblePane() {
        setOpaque(false);
        getViewport().setOpaque(false);
        getViewport().setBackground(UIHelper.TRANSPARENT);
        setBorder(BorderFactory.createEmptyBorder());
    }

    /**
     * Remove horizontal scrolling and set the vertical scrollbar to invisible
     */
    private void setScrollBars() {
        verticalScrollBar.setOpaque(false);
        verticalScrollBar.setUI(new DisappearingScrollBar());
        verticalScrollBar.addAdjustmentListener(new AdjustmentListener(){
            @Override
            public void adjustmentValueChanged(AdjustmentEvent e) {
                verticalScrollBar.setUI(new DisappearingScrollBar());
                _timer.stop();
                _timer.start();
            }
        });
        setComponentZOrder(verticalScrollBar, 0);
        setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);

        setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
    }

    /**
     * Sets the location of the scrollbar.
     * Expand the viewbox such that the scrollbar is within and not outside the
     * box.
     */
    private void setViewBox() {
        setLayout(new ScrollPaneLayout() {
            @Override
            public void layoutContainer(Container parent) {
                JScrollPane scrollPane = (JScrollPane)parent;

                Rectangle viewBox = scrollPane.getBounds();
                viewBox.x = 0;
                viewBox.y = 0;

                Rectangle scrollTrack = new Rectangle();
                scrollTrack.width  = BAR_WIDTH;
                scrollTrack.height = viewBox.height;
                scrollTrack.x = viewBox.x + viewBox.width - scrollTrack.width;
                scrollTrack.y = viewBox.y;

                if(viewport != null) {
                    viewport.setBounds(viewBox);
                }
                if(vsb != null) {
                    vsb.setVisible(true);
                    vsb.setBounds(scrollTrack);
                }
            }
        });
    }

    /**
     * Timer to set the scrollbar to invisible
     */
    private void setTimeout() {
        _timer = new Timer(VANISH_TIMER, new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent e) {
                verticalScrollBar.setUI(null);
                _timer.stop();
            }
        });
    }

    /**
     * Creating the scrollbar
     */
    private static class DisappearingScrollBar extends BasicScrollBarUI {

        @Override
        protected JButton createDecreaseButton(int orientation) {
            return invisibleButton();
        }

        @Override
        protected JButton createIncreaseButton(int orientation) {
            return invisibleButton();
        }

        /**
         * the track the scrollbar lays on. Set to nothing.
         */
        @Override
        protected void paintTrack(Graphics g, JComponent c, Rectangle trackBounds) {
        }

        /**
         * the actual scrollbar
         */
        @Override
        protected void paintThumb(Graphics g, JComponent c, Rectangle thumbBounds) {
            UIHelper.paintRoundedRectangle(g, ThemeReader.getScrollColor(),
                                           thumbBounds.x,thumbBounds.y, BAR_WIDTH,
                                           thumbBounds.height, BAR_ROUNDNESS);
        }

        /**
         * create an invisible JButton for the scrollbar
         *
         * @return an invisible JButton
         */
        private static JButton invisibleButton() {
            JButton invisibleButton = new JButton() {
                @Override
                public Dimension getPreferredSize() {
                    return new Dimension(0, 0);
                }
            };
            return invisibleButton;
        }
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\BakaScrollPane.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\BakaUI.java
	 */


package bakatxt.gui;

import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.List;

import javax.swing.JFrame;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;

import bakatxt.core.BakaProcessor;
import bakatxt.core.Task;
import bakatxt.gui.look.UIHelper;

import com.tulskiy.keymaster.common.HotKey;
import com.tulskiy.keymaster.common.HotKeyListener;
import com.tulskiy.keymaster.common.Provider;

/**
 * BakaUI is the "main window" of the GUI for BakaTXT. Since we are doing a custom
 * window design, BakaUI is actually completely transparent. We will instead draw
 * a BakaPanel that fills the BakaUI window, and treat it as our actual window.
 *
 */
public class BakaUI extends JFrame {

    private static BakaUI _bakaUI;
    private static BakaPanel _bakaPanel;
    private static BakaProcessor _bakaProcessor;

    private static final String INITIAL_DISPLAY = "display today";
    private static final String HOTKEY = "control SPACE";

    private static final Provider provider = Provider.getCurrentProvider(true);

    /**
     * @param thisSession
     *        refers to the logic module we are interacting with
     */
    private BakaUI(BakaProcessor bakaProcessor) {
        _bakaProcessor = bakaProcessor;
        initUI();
        setupHotkey();
    }

    /**
     * This method initializes the GUI and updates it when necessary
     */
    public static void startGui(BakaProcessor bakaProcessor) {
        _bakaUI = new BakaUI(bakaProcessor);
        _bakaUI.setVisible(true);
        _bakaUI.setLocation(UIHelper.WINDOW_LOCATION);
        setInitialFocus();
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                setInitialDisplay();
                processInput();
            }
        });
    }

    /**
     * This method listens for input from the GUI and does the following when the
     * return key is pressed:
     *
     * 1. Highlight all the text in the input box (to make it trivial for the user
     * to input new commands)
     * 2. Passes the input to the logic module to process it
     * 3. Lastly, updates the contents of the GUI to fit the command
     */
    public static void processInput() {

        Input input = _bakaPanel.getInput();
        input.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                input.selectAll();
                String s = input.getText();
                shouldAnimate(processInput(s));
                updateUI(_bakaProcessor.getAllTasks());
            }
        });
    }

    /**
     * update the contents of the GUI
     */
    public static void updateUI(List<Task> tasks) {

        assert (tasks != null) : "tasks must not be null";

        _bakaPanel.refreshContents(tasks);
        _bakaUI.setLocation(UIHelper.WINDOW_LOCATION);

        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                _bakaUI.setPreferredSize(new Dimension(UIHelper.WINDOW_X,
                        _bakaPanel.getPreferredSize().height));
                _bakaUI.pack();
            }
        });
    }

    /**
     * Set the text within the input box
     *
     * @param s
     *        the string to be put in the input box
     */
    public static void setInputBoxText(String s) {
        _bakaPanel.setInputBoxText(s);
        _bakaPanel.getInput().selectAll();
    }

    /**
     * Set the text in the alert message box
     *
     * @param s
     *        the string to put in the alert message box
     */
    public static void setAlertMessageText(String s) {
        _bakaPanel.updateAlertMessageText(s);
    }

    /**
     * @return the JFrame window
     */
    public static BakaUI getWindow() {
        return _bakaUI;
    }

    /**
     * @return the Jpanel with all the content
     */
    public static BakaPanel getPanel() {
        return _bakaPanel;
    }

    /**
     * This method draws the BakaPanel and sets the window as transparent and
     * centered.
     */
    private void initUI() {
        try {
            _bakaPanel = new BakaPanel(_bakaProcessor.getAllTasks());
        } catch (NullPointerException e) {
            throw new Error("bakaProcessor.getAllTasks() is null");
        }
        setUndecorated(true);
        setBackground(UIHelper.TRANSPARENT);
        setContentPane(_bakaPanel);
        pack();
        setAlwaysOnTop(false);
        setTitle("BakaTxt");
        setDefaultCloseOperation(EXIT_ON_CLOSE);
    }

    /**
     * Set the input box to be immediately selected on start up
     */
    private static void setInitialFocus() {
        _bakaUI.addWindowListener(new WindowAdapter() {
            @Override
            public void windowOpened( WindowEvent e ){
                _bakaPanel.getInput().requestFocus();
            }
        });
    }

    /**
     * Set the UI to show today's tasks on startup
     */
    private static void setInitialDisplay() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                processInput(INITIAL_DISPLAY);
                updateUI(_bakaProcessor.getAllTasks());
            }
        });
    }

    /**
     * Process the input by giving it to bakaProcessor
     *
     * @param inputText
     *        the string to be processed
     * @return true if the command was successfully executed
     */
    private static boolean processInput(String inputText) {
        return _bakaProcessor.executeCommand(inputText);
    }

    /**
     * Animates the components to be animated
     *
     * @param shouldAnimate
     *        is the boolean controlling the animation
     */
    private static void shouldAnimate(boolean shouldAnimate) {
        _bakaPanel.animateInputBox(shouldAnimate);
    }

    /**
     * Set up the hotkey for the user to launch bakatxt with
     */
    private static void setupHotkey() {
        final HotKeyListener listener = new HotKeyListener() {
            @Override
            public void onHotKey(final HotKey hotKey) {
                EventQueue.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        _bakaUI.setAlwaysOnTop(true);
                        _bakaUI.toFront();
                        _bakaUI.requestFocus();
                        _bakaUI.setAlwaysOnTop(false);
                    }
                });
            }
        };
        provider.reset();
        provider.register(KeyStroke.getKeyStroke(HOTKEY), listener);
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\BakaUI.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\Contents.java
	 */

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\Contents.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\Contents.java
	 */


package bakatxt.gui;

import java.awt.Color;
import java.util.LinkedList;
import java.util.List;

import javax.swing.BoxLayout;
import javax.swing.JPanel;

import bakatxt.core.Task;
import bakatxt.gui.look.ThemeReader;
import bakatxt.gui.look.UIHelper;
import bakatxt.international.BakaTongue;

/**
 * This class does the following:
 *
 * 1. Draw the alert message (i.e, visual feedback for user's input)
 * 2. Draw the date and content for each date
 *
 */
class Contents extends JPanel {

    private static final String MESSAGE_EMPTY = "null";

    private static final int DATE_AND_TASKS_START_POSITION = 1;

    public Contents(List<Task> tasks) {

        setOpaque(false);
        setBackground(UIHelper.TRANSPARENT);
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        List<Task> tempTasks = tasks;
        updateContents(tempTasks);
    }

    /**
     * Check if tasks is empty, displaying the appropriate events.
     *
     * @param tasks
     *        is all the tasks in the List<Task> we need to add
     */
    protected void updateContents(List<Task> tasks) {
        try {
            addTasksByDate((LinkedList<Task>)tasks);
        } catch (NullPointerException e) {
            setNoEvents();
        }
    }

    /**
     * Takes a LinkedList<Task> and puts it into the dateAndDay and Events "boxes"
     *
     * @param tasks
     *        is all the tasks in the LinkedList<Task> we need to add
     */
    private void addTasksByDate(LinkedList<Task> tasks) {
        String currentDate;
        int y = DATE_AND_TASKS_START_POSITION;
        int offset = 0;

        while (tasks.peek() != null) {

            currentDate = tasks.peek().getFormattedDate();

            setDateAndDay(setDayAndDateText(currentDate));
            offset++;
            y = addCurrentEvents(getAllTasksInOneDate(tasks), y + 1, offset);
        }
    }

    /**
     * This method takes a LinkedList<Task> and splits that LinkedList by date into
     * smaller LinkedLists
     *
     * @param tasks
     *        is the task to be split
     * @return a LinkedList<Task> of the earliest date
     */
    private static LinkedList<Task> getAllTasksInOneDate(LinkedList<Task> tasks) {

        LinkedList<Task> seperateTasksByDate = new LinkedList<Task>();
        String currentDate = tasks.peek().getDate();

        while (isSameDate(tasks, currentDate)) {
            seperateTasksByDate.add(tasks.poll());
        }

        return seperateTasksByDate;
    }

    /**
     * Checks if the first element of a LinkedList<Task> has the same date as currentDate
     *
     * @param tasks
     *        is the LinkedList we are checking
     * @param currentDate
     *        is the date we are comparing to
     * @return true if the date is the same, false if it isn't or if the LinkedList
     *         is empty.
     */
    private static boolean isSameDate(LinkedList<Task> tasks, String currentDate) {

        if (tasks.peek() == null) {
            return false;
        }

        String taskDate = tasks.peek().getDate();

        if (currentDate == null) {
            currentDate = MESSAGE_EMPTY;
        }
        if (taskDate == null) {
            taskDate = MESSAGE_EMPTY;
        }
        return taskDate.equals(currentDate);
    }

    /**
     * add all the tasks in the LinkedList into the GUI for that date
     *
     * @param tasks
     *        the list of tasks
     * @param y
     *        the positioning in the GUI
     * @param offset
     *        the offset to be calculated for the task number
     * @return the new y value after adding these tasks
     */
    private int addCurrentEvents(LinkedList<Task> tasks, int y, int offset) {

        assert (y > 0) : "y must be greater than zero";
        assert (offset > 0) : "offset must be at least 1";
        int taskNumber = y - offset;
        TaskBox taskBox;

        /**
         * case where there is only one task in the list
         */
        if (tasks.size() == 1) {
            taskBox = new OnlyTaskBox(tasks.pop(), taskNumber,
                                      alternatingColors(taskNumber));
            setEvents(taskBox);
            shouldAnimate(taskBox);
            taskNumber++;
          /**
           * case where there are >1 tasks in the list
           * case where the current task is the first task
           */
        } else {
            taskBox = new FirstTaskBox(tasks.pop(), taskNumber,
                                       alternatingColors(taskNumber));
            setEvents(taskBox);
            taskNumber++;

            while (true) {
                /**
                 * case where the current task is the last one in the list
                 */
                if (tasks.size() == 1) {
                    taskBox = new FinalTaskBox(tasks.pop(), taskNumber,
                                               alternatingColors(taskNumber));
                    setEvents(taskBox);
                    shouldAnimate(taskBox);
                    taskNumber++;
                    break;
                }
                /**
                 * all other cases
                 */
                taskBox = new MiddleTaskBox(tasks.pop(), taskNumber,
                                            alternatingColors(taskNumber));
                setEvents(taskBox);
                taskNumber++;
            }
        }
        return taskNumber + offset;
    }

    /**
     * sets the color of the taskbox based on it's location in the GUI
     *
     * @param taskNumber
     *        is the location of the task in thr GUI
     * @return the color the taskbox should be
     */
    private static Color alternatingColors(int taskNumber) {
        if (taskNumber % 2 == 0) {
            return ThemeReader.getTaskDarkColor();
        }
        return ThemeReader.getTaskLightColor();
    }

    /**
     * @param alertMessage
     *        is the message to put in the layout specified
     */
    private void setDateAndDay(FormattedText dateAndDay) {
        this.add(dateAndDay);
    }

    /**
     * @param task
     *        is the taskbox to animate
     */
    private static void shouldAnimate(TaskBox task) {
    }

    /**
     * @param task
     *        is the message to put in the layout specified
     */
    private void setEvents(TaskBox task) {
        setTaskBoxSize(task);
        this.add(task);
    }

    /**
     * What to show when there are no events
     */
    private void setNoEvents() {
        FormattedText task = new FormattedText("You have no events!",
                                               ThemeReader.getTitleTheme());
        this.add(task);
    }

    /**
     * set the size of the taskbox
     * @param task
     *        is the taskbox whose size is to be set
     */
    private static void setTaskBoxSize(TaskBox task) {
        task.setMinimumSize(UIHelper.TASKBOX_SIZE);
        task.setPreferredSize(UIHelper.TASKBOX_SIZE);
        task.setMaximumSize(UIHelper.TASKBOX_SIZE);
    }

    /**
     * @param dayAndDate
     *        is the string to style
     * @return a day and date FormattedText with the string
     */
    private static FormattedText setDayAndDateText(String dayAndDate) {

        if (dayAndDate == null || dayAndDate.equals(MESSAGE_EMPTY)) {
            dayAndDate = BakaTongue.getString("MESSAGE_FLOATING");
        }

        return new FormattedText(dayAndDate, ThemeReader.getDateTheme());
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\Contents.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\FinalTaskBox.java
	 */


package bakatxt.gui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Path2D;

import bakatxt.core.Task;
import bakatxt.gui.look.UIHelper;

/**
 * This class dictates the color and shape of the box which the task will be put in.
 * This box is specifically for a bottom most box.
 *
 */
final class FinalTaskBox extends TaskBox {

    public FinalTaskBox(Task task, int index, Color backgroundColor) {
        super(task, index, backgroundColor);
    }

    @Override
    protected void paintComponent(Graphics g) {
        Graphics2D g2d = (Graphics2D) g.create();
        g2d.setColor(getBackground());
        g2d.setRenderingHints(UIHelper.antiAlias());
        g2d.fill(new BottomRounded(getWidth(), getHeight()));
        g2d.dispose();
        super.paintComponent(g);
    }

    /**
     * This class draws curved corners for the bottom corners of a rectangle
     *
     */
    class BottomRounded extends Path2D.Double {

        public BottomRounded(double width, double height) {
            moveTo(0, 0);
            lineTo(width, 0);
            lineTo(width, height - UIHelper.WINDOW_ROUNDNESS);
            curveTo(width, height, width, height, width - UIHelper.WINDOW_ROUNDNESS, height);
            lineTo(UIHelper.WINDOW_ROUNDNESS, height);
            curveTo(0, height, 0, height, 0, height - UIHelper.WINDOW_ROUNDNESS);
            lineTo(0, 0);
            closePath();
        }
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\FinalTaskBox.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\FirstTaskBox.java
	 */


package bakatxt.gui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Path2D;

import bakatxt.core.Task;
import bakatxt.gui.look.UIHelper;

/**
 * This class dictates the color and shape of the box which the task will be put in.
 * This box is specifically for a top most box.
 *
 */
final class FirstTaskBox extends TaskBox {

    public FirstTaskBox(Task task, int index, Color backgroundColor) {
        super(task, index, backgroundColor);
    }

    @Override
    protected void paintComponent(Graphics g) {
        Graphics2D g2d = (Graphics2D) g.create();
        g2d.setColor(getBackground());
        g2d.setRenderingHints(UIHelper.antiAlias());
        g2d.fill(new TopRounded(getWidth(), getHeight()));
        g2d.dispose();
        super.paintComponent(g);
    }

    /**
     * This class draws curved corners for the top corners of a rectangle
     *
     */
    class TopRounded extends Path2D.Double {

        public TopRounded(double width, double height) {
            moveTo(0, height);
            lineTo(0, UIHelper.WINDOW_ROUNDNESS);
            curveTo(0, 0, 0, 0, UIHelper.WINDOW_ROUNDNESS, 0);
            lineTo(width - UIHelper.WINDOW_ROUNDNESS, 0);
            curveTo(width, 0, width, 0, width, UIHelper.WINDOW_ROUNDNESS);
            lineTo(width, height);
            lineTo(0, height);
            closePath();
        }
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\FirstTaskBox.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\FormattedText.java
	 */


package bakatxt.gui;

import java.awt.Font;
import java.awt.Graphics;

import javax.swing.JTextArea;

import bakatxt.gui.look.BakaTheme;
import bakatxt.gui.look.ThemeReader;
import bakatxt.gui.look.UIHelper;

/**
 * This class is used for each of the text elements
 *
 */
@SuppressWarnings("boxing")
class FormattedText extends JTextArea {

    public FormattedText(String s, BakaTheme theme) {
        this(s, theme, false);
    }

    public FormattedText(String s, BakaTheme theme, boolean isLineWrap) {
        setOpaque(false);
        setTheme(theme);
        setBackground(UIHelper.TRANSPARENT);
        setEditable(false);
        setLineWrap(isLineWrap);
        setWrapStyleWord(true);
        setText(s);
    }

    /**
     * Refresh the colors and typeface when a new theme is set
     *
     * @param theme
     *        is the new theme set
     */
    protected void setTheme(BakaTheme theme) {
        setFont(new Font(ThemeReader.getTypeface(), theme.getFontType(),
                         theme.getFontSize()));
        setForeground(theme.getColor());
    }

    @Override
    protected void paintBorder(Graphics g) {
        g.setColor(UIHelper.TRANSPARENT);
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\FormattedText.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\Input.java
	 */


package bakatxt.gui;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Shape;
import java.awt.geom.RoundRectangle2D;

import javax.swing.JTextField;

import bakatxt.gui.look.BakaAnimator;
import bakatxt.gui.look.BakaTheme;
import bakatxt.gui.look.ThemeReader;
import bakatxt.gui.look.UIHelper;

/**
 * This class sets the input box for BakaUI
 *
 */
public class Input extends JTextField implements BakaAnimator {

    /**
     * Needed to read mouse clicks on the input box
     */
    private Shape shape;

    /**
     * Color of the input box
     */
    private Color _baseColor;

    /**
     * Relative location of the input box
     */
    private final Point _baseLocation;

    private BakaTheme _theme;

    public Input() {
        setOpaque(false);
        setTheme();
        setFocusTraversalKeysEnabled(false);

        _baseLocation = new Point(2 * UIHelper.BORDER, 2 * UIHelper.BORDER);
    }

    /**
     * refresh the colors and the font when a new theme is set
     */
    @SuppressWarnings("boxing")
    protected void setTheme() {
        _theme = ThemeReader.getInteractTheme();
        setFont(new Font(ThemeReader.getTypeface(), _theme.getFontType(),
                         _theme.getFontSize()));
        setBackground(ThemeReader.getInputColor());
        setForeground(_theme.getColor());
        setCaretColor(_theme.getColor());
        setSelectedTextColor(_theme.getColor());
        setSelectionColor(ThemeReader.getSelectionColor());
        _baseColor = ThemeReader.getInputColor();
    }

    /**
     * Paint the input box
     */
    @Override
    protected void paintComponent(Graphics g) {
        UIHelper.paintRoundedRectangle(g, getBackground(), getWidth(), getHeight());
        super.paintComponent(g);
    }

    /**
     * Make the border of the input box transparent
     */
    @Override
    protected void paintBorder(Graphics g) {
        g.setColor(UIHelper.TRANSPARENT);
    }

    /**
     * Read mouse clicks on the input box
     */
    @Override
    public boolean contains(int x, int y) {
        if (shape == null || !shape.getBounds().equals(getBounds())) {
            shape = new RoundRectangle2D.Float(0, 0, getWidth(), getHeight(),
                    UIHelper.WINDOW_ROUNDNESS, UIHelper.WINDOW_ROUNDNESS);
        }
        return shape.contains(x, y);
    }

    /**
     * @see {@link bakatxt.gui.look.BakaAnimator}
     */
    @Override
    public Color getColor() {
        return _baseColor;
    }

    /**
     * @see {@link bakatxt.gui.look.BakaAnimator}
     */
    @Override
    public void setColor(Color newColor) {
        setBackground(newColor);
    }

    /**
     * @see {@link bakatxt.gui.look.BakaAnimator}
     */
    @Override
    public Point getPoint() {
        return _baseLocation;
    }

    /**
     * @see {@link bakatxt.gui.look.BakaAnimator}
     */
    @Override
    public void setPoint(Point newLocation) {
        setLocation(newLocation);
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\Input.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\look\BakaAnimator.java
	 */


package bakatxt.gui.look;

import java.awt.Color;
import java.awt.Point;

/**
 * Any class that wishes to use UIAnimator must implement this interface
 *
 */
public interface BakaAnimator {

    /**
     * A final variable needs to be set for the base color of the component so that
     * the UIAnimator can return the component to it's correct color. This method
     * retrieves said final color.
     *
     * @return the base color of the component
     */
    public Color getColor();

    /**
     * This method should pass the color to setBackground() for Swing components
     *
     * @param newColor is the temporary color to set the component to
     */
    public void setColor(Color newColor);

    /**
     * A final variable needs to be set for the base location of the component so that
     * the UIAnimator can return the component to it's correct location. This method
     * retrieves said final location.
     *
     * @return the original location of the component
     */
    public Point getPoint();

    /**
     * This method should pass the location to setLocation() for Swing components
     *
     * @param newLocation is the temporary location to set the component to
     */
    public void setPoint(Point newLocation);
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\look\BakaAnimator.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\look\BakaTheme.java
	 */


package bakatxt.gui.look;

import java.awt.Color;

/**
 * This is a theme object for the text in the GUI
 *
 */
public class BakaTheme {

    private Integer _fontSize;
    private Integer _fontType;
    private Color _color;

    /**
     * @param color
     *        the color of the component
     * @param fontSize
     *        font size of the type
     * @param fontType
     *        whether the font is regular, italic or bold
     */
    public BakaTheme(Color color, Integer fontType, Integer fontSize) {
        _color = color;
        _fontSize = fontSize;
        _fontType = fontType;
    }

    /**
     * @return the color of the theme
     */
    public Color getColor() {
        return _color;
    }

    /**
     * @return the font size of the theme
     */
    public Integer getFontSize() {
        return _fontSize;
    }

    /**
     * @return regular, italic or bold font
     */
    public Integer getFontType() {
        return _fontType;
    }

    public void setColor(Color color) {
        _color = color;
    }

    public void setFontSize(Integer fontSize) {
        _fontSize = fontSize;
    }

    public void setFontType(Integer fontType) {
        _fontType = fontType;
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\look\BakaTheme.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\look\ThemeReader.java
	 */


package bakatxt.gui.look;

import static java.lang.Integer.valueOf;

import java.awt.Color;
import java.awt.Font;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Collections;
import java.util.LinkedList;

import bakatxt.core.Database;
import bakatxt.core.Task;
import bakatxt.international.BakaTongue;

/**
 * This class controls the colors as well as the fonts of the GUI from the theme
 *
 */
@SuppressWarnings("boxing")
public class ThemeReader {

    private static final String EXT = ".bakaTheme";
    private static final String HEADER = BakaTongue.getString("COMMAND_THEME");

    /**
     * The font to use for the GUI
     */
    private static String _typeface = "Arial";

    /**
     * Colors for the boxes in the GUI
     */
    private static Color _input = new Color(100, 100, 100);
    private static Color _panel = new Color(66, 66, 66);
    private static Color _taskLight = new Color(48, 48, 48);
    private static Color _taskDark = new Color(36, 36, 36);
    private static Color _scroll = new Color(0, 0, 0, 100);
    private static Color _selection = new Color(0, 0, 0, 150);

    /**
     * Color, font size, and font type of various elements in the GUI
     */
    private static BakaTheme _date = new BakaTheme(new Color(253, 184, 19),
                                                   Font.PLAIN, 12);
    private static BakaTheme _alert = new BakaTheme(new Color(250, 250, 250),
                                                    Font.PLAIN, 12);
    private static BakaTheme _location = new BakaTheme(new Color(227, 122, 37),
                                                       Font.BOLD, 14);
    private static BakaTheme _number = new BakaTheme(new Color(80, 80, 80),
                                                     Font.PLAIN, 16);
    private static BakaTheme _title = new BakaTheme(new Color(239, 62, 47),
                                                    Font.BOLD, 18);
    private static BakaTheme _interact = new BakaTheme(new Color(228, 224, 227),
                                                        Font.PLAIN, 24);
    private static BakaTheme _default = new BakaTheme(new Color(228, 224, 227),
                                                      Font.PLAIN, 12);

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\look\ThemeReader.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\look\ThemeReader.java
	 */

    /**
     * @return the typeface to be used in the GUI
     */
    public static String getTypeface() {
        return _typeface;
    }

    /**
     * @return the color of the input box to be used
     */
    public static Color getInputColor() {
        return _input;
    }

    /**
     * @return the color of the main background to be used
     */
    public static Color getPanelColor() {
        return _panel;
    }

    /**
     * @return the lighter color of the task box to be used
     */
    public static Color getTaskLightColor() {
        return _taskLight;
    }

    /**
     * @return the darker color of the task box to be used
     */
    public static Color getTaskDarkColor() {
        return _taskDark;
    }

    /**
     * @return the color of the scrollbar to be used
     */
    public static Color getScrollColor() {
        return _scroll;
    }

    /**
     * @return the text selection color to be used
     */
    public static Color getSelectionColor() {
        return _selection;
    }

    /**
     * @return the style of the date text to be used
     */
    public static BakaTheme getDateTheme() {
        return _date;
    }

    /**
     * @return the style of the alert text to be used
     */
    public static BakaTheme getAlertTheme() {
        return _alert;
    }

    /**
     * @return the style of the location text to be used
     */
    public static BakaTheme getLocationTheme() {
        return _location;
    }

    /**
     * @return the style of the task number to be used
     */
    public static BakaTheme getNumberTheme() {
        return _number;
    }

    /**
     * @return the style of the title of the task to be used
     */
    public static BakaTheme getTitleTheme() {
        return _title;
    }

    /**
     * @return the style of the text in the input box to be used
     */
    public static BakaTheme getInteractTheme() {
        return _interact;
    }

    /**
     * @return th style of any other text in the program to be used
     */
    public static BakaTheme getDefaultTheme() {
        return _default;
    }

    /**
     * reads the theme from a file
     *
     * @param filePath
     *        the path to the file to be used
     */
    private static void readFile(Path filePath) {
        try (BufferedReader inputStream = Files.newBufferedReader(filePath,
                                          Charset.forName("UTF-8"))) {
            String line;
            while ((line = inputStream.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }
                setThemes(line);
            }
        } catch (IOException ex) {
            // TODO log printStackTrace()
        }
    }

    /**
     * sets the new theme from the theme file, if information is missing,
     * that information is set to the last one used
     *
     * @param line
     *        is each line of the theme file
     */
    private static void setThemes(String line) {
        try {
            String[] thisTheme = line.split("=");
            if (thisTheme[1] == null) {
                return;
            }
            thisTheme[0] = thisTheme[0].trim();
            thisTheme[1] = thisTheme[1].trim();
            switch (thisTheme[0].toUpperCase()) {
                case "TYPEFACE" :
                    setTypeface(thisTheme[1]);
                    break;
                case "INPUT" :
                    setInput(thisTheme[1]);
                    break;
                case "PANEL" :
                    setPanel(thisTheme[1]);
                    break;
                case  "TASK1" :
                    setTaskLight(thisTheme[1]);
                    break;
                case "TASK2" :
                    setTaskDark(thisTheme[1]);
                    break;
                case "SCROLLBAR" :
                    setScroll(thisTheme[1]);
                    break;
                case "SELECTION" :
                    setSelection(thisTheme[1]);
                    break;
                case "DATE" :
                    setDate(thisTheme[1]);
                    break;
                case "ALERT" :
                    setAlert(thisTheme[1]);
                    break;
                case "LOCATION" :
                    setLocation(thisTheme[1]);
                    break;
                case "NUMBER" :
                    setNumber(thisTheme[1]);
                    break;
                case "TITLE" :
                    setTitle(thisTheme[1]);
                    break;
                case "INTERACT" :
                    setInteract(thisTheme[1]);
                    break;
                case "DEFAULT" :
                    setDefault(thisTheme[1]);
                    break;
                default :
                    break;
            }
        } catch (NullPointerException e) {
        }
    }

    private static void setTypeface(String typeface) {
        _typeface = typeface;
    }

    private static void setInput(String input) {
        _input = setToOriginalIfNull(_input, readColor(input));
    }

    private static void setPanel(String panel) {
        _panel = setToOriginalIfNull(_panel, readColor(panel));
    }

    private static void setTaskLight(String taskLight) {
        _taskLight = setToOriginalIfNull(_taskLight, readColor(taskLight));
    }

    private static void setTaskDark(String taskDark) {
        _taskDark = setToOriginalIfNull(_taskDark, readColor(taskDark));
    }

    private static void setScroll(String scroll) {
        _scroll = setToOriginalIfNull(_scroll, readColor(scroll));
    }

    private static void setSelection(String selection) {
        _selection = setToOriginalIfNull(_selection, readColor(selection));
    }

    private static void setDate(String date) {
        _date = setToOriginalIfNull(_date, readTheme(date));
    }

    private static void setAlert(String alert) {
        _alert = setToOriginalIfNull(_alert, readTheme(alert));
    }

    private static void setLocation(String location) {
        _location = setToOriginalIfNull(_location, readTheme(location));
    }

    private static void setNumber(String number) {
        _number = setToOriginalIfNull(_number, readTheme(number));
    }

    private static void setTitle(String title) {
        _title = setToOriginalIfNull(_title, readTheme(title));
    }

    private static void setInteract(String interact) {
        _interact = setToOriginalIfNull(_interact, readTheme(interact));
    }

    private static void setDefault(String defaultText) {
        _default = setToOriginalIfNull(_default, readTheme(defaultText));
    }

    /**
     * reads a string which specifies a BakaTheme
     *
     * @param theme
     *        is the BakaTheme in the form of a string
     * @return the BakaTheme from the string
     */
    private static BakaTheme readTheme(String theme) {
        try {
            String[] bakaTheme = theme.split("&");
            if (bakaTheme.length == 3) {
                return stringToTheme(bakaTheme[0], bakaTheme[1], bakaTheme[2]);
            }
            return null;
        } catch (NullPointerException e) {
            return null;
        }
    }

    /**
     * reads a string which specifies a color
     *
     * @param color
     *        is the color in the form of a string
     * @return the color from the string
     */
    private static Color readColor(String color) {
        try {
            color = trimString(color);
            String[] rgba = color.split(",");
            if (rgba.length == 3) {
                return stringToColor(rgba[0], rgba[1], rgba[2]);
            } else if (rgba.length == 4) {
                return stringToColor(rgba[0], rgba[1], rgba[2], rgba[3]);
            }
            return null;
        } catch (NullPointerException e) {
            return null;
        }
    }

    /**
     * reads a string which specifies a font type
     *
     * @param fontType
     *        is the font type in the form of a string
     * @return the font type from the string
     */
    private static Integer readFontType(String fontType) {
        switch (fontType.trim()) {
            case "PLAIN" :
                return Font.PLAIN;
            case "BOLD" :
                return Font.BOLD;
            case "ITALIC" :
                return Font.ITALIC;
            default :
                return null;
        }
    }

    /**
     * reads a string which specifies a font size
     *
     * @param fontSize
     *        is the size of the font in the form of a string
     * @return the font size from the string
     */
    private static Integer readFontSize(String fontSize) {
        try {
            return valueOf(fontSize.trim());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /**
     * decide whether or not to set the theme of the element to what was used
     * previously based on null values detected
     *
     * @param original
     *        the initial BakaTheme
     * @param newTheme
     *        the new BakaTheme
     * @return the BakaTheme without null values
     */
    private static BakaTheme setToOriginalIfNull(BakaTheme original,
                                                 BakaTheme newTheme) {
        if (newTheme == null) {
            return original;
        }
        newTheme.setColor(setToOriginalIfNull(original.getColor(),
                                               newTheme.getColor()));
        newTheme.setFontSize(setToOriginalIfNull(original.getFontSize(),
                                                  newTheme.getFontSize()));
        newTheme.setFontType(setToOriginalIfNull(original.getFontType(),
                                                  newTheme.getFontType()));

        return newTheme;
    }

    /**
     * decide whether or not to set the color of the element to what was used
     * previously based on null values detected
     *
     * @param original
     *        the initial Color
     * @param newColor
     *        the new Color
     * @return the Color without null values
     */
    private static Color setToOriginalIfNull(Color original, Color newColor) {
        if (newColor == null) {
            return original;
        }
        return newColor;
    }

    /**
     * decide whether or not to set the integer of the element to what was used
     * previously based on null values detected
     *
     * @param original
     *        the initial int
     * @param newInt
     *        the new integer
     * @return the int without null values
     */
    private static int setToOriginalIfNull(int original, Integer newInt) {
        if (newInt == null) {
            return original;
        }
        return newInt;
    }

    private static BakaTheme stringToTheme(String color, String fontType,
                                           String fontSize) {
        return new BakaTheme(readColor(color), readFontType(fontType),
                             readFontSize(fontSize));
    }

    /**
     * Trim the first and last character in a string, in our case, '(' and ')'
     *
     * @param string
     *        the string we are trimming the characters
     * @return the string after trimming
     */
    private static String trimString(String string) {
        string = string.trim();
        return string.substring(1, string.length() - 1);
    }

    /**
     * takes a Color in the form of a string and change it to an object, returning
     * null if the color is invalid
     *
     * @param red
     *        red component of Color
     * @param green
     *        green component of Color
     * @param blue
     *        blue component of Color
     * @return the new color or null if it is an invalid color
     */
    private static Color stringToColor(String red, String green, String blue) {
        return stringToColor(red, green, blue, "255");
    }

    /**
     * takes a Color in the form of a string and change it to an object, returning
     * null if the color is invalid
     *
     * @param red
     *        red component of Color
     * @param green
     *        green component of Color
     * @param blue
     *        blue component of Color
     * @param alphs
     *        alpha component of Color
     * @return the new color or null if it is an invalid color
     */
    private static Color stringToColor(String red, String green, String blue,
                                       String alpha) {
        try {
            return new Color(valueOf(red), valueOf(green), valueOf(blue),
                             valueOf(alpha));
        } catch (NumberFormatException e) {
            return null;
        } catch (IllegalArgumentException e) {
            return null;
        }
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\look\ThemeReader.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\look\UIAnimator.java
	 */


package bakatxt.gui.look;

import java.awt.Color;
import java.awt.Point;

import javax.swing.SwingUtilities;

/**
 * This class holds methods for animations used in BakaTxt
 */
public class UIAnimator {

    /**
     * Maximum length of time in miliseconds the animations should be
     */
    private static final int TIME_LENGTH = 640;

    /**
     * delay between animation frames
     */
    private static final int DELAY = 20;

    /**
     * number of iterations the input box should be changing color
     */
    private static final int ITERATIONS_FLASH = TIME_LENGTH / DELAY;

    /**
     * number of times the input box shakes, '4' is the number of times the delay
     * is used in the following method
     * @see {@link #shakeOneIteration(Point, int)}
     */
    private static final int ITERATIONS_SHAKE = TIME_LENGTH / DELAY / 4;

    /**
     * in typical RGB, the value of each color ranges from 0-255, this is just
     * to signify the 255 value
     */
    private static final float MAX_COLOR = 255;

    /**
     * the amount of change in color per iteration
     */
    private static final float DELTA = (float)0.0030637255;

    /**
     *  the component we are animating
     */
    private static BakaAnimator _component;

    public UIAnimator(BakaAnimator component) {
        _component = component;
    }

    /**
     * Vibrates the component
     */
    public void shakeComponent() {
        for (int i = 0; i < ITERATIONS_SHAKE; i++) {
            shakeOneIteration(_component.getPoint(), ITERATIONS_SHAKE - i);
        }
    }

    /**
     * Flashes the component's color, flash does not animate if isExceedMaximumColor
     * is triggered.
     */
    public void flashComponent() {

        float red = getColorAsFloat(_component.getColor().getRed());
        float green = getColorAsFloat(_component.getColor().getGreen());
        float blue = getColorAsFloat(_component.getColor().getBlue());

        if(!isExceedMaximumColor(red, green, blue)) {
            for (int i = ITERATIONS_FLASH; i > 0; i--) {
                float extraColor = DELTA * i;
                setColor(new Color(red + extraColor,
                                   green + extraColor,
                                   blue + extraColor));
                waitAWhile();
            }
            setColor(_component.getColor());
        }
    }

    /**
     * Shake the component right, then back to initial, then left, then back to initial
     * again.
     *
     * @param initialLocation
     *        is the initial location of the component to be shaked
     * @param movementDelay
     *        is the delay between shakes
     * @param xMovement
     *        is the amount to move the component by
     */
    private static void shakeOneIteration(final Point initialLocation, int xMovement) {
        moveBox(new Point(initialLocation.x + xMovement, initialLocation.y));
        waitAWhile();
        moveBox(initialLocation);
        waitAWhile();
        moveBox(new Point(initialLocation.x - xMovement, initialLocation.y));
        waitAWhile();
        moveBox(initialLocation);
        waitAWhile();
    }

    /**
     * Moves the input box to the set location
     *
     * @param p
     *        is the Point to move the box to
     */
    private static void moveBox(final Point p) {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                _component.setPoint(p);
            }
        });
    }

    /**
     * Ensure that the 3 components of color does not exceed 1 during the animation
     *
     * @param red
     *        red component of light
     * @param green
     *        green component of light
     * @param blue
     *        blue component of light
     * @return true if any color exceeds 1
     */
    private static boolean isExceedMaximumColor(float red, float green, float blue) {
        return isExceedMaximumColor(red) ||
               isExceedMaximumColor(green) ||
               isExceedMaximumColor(blue);
    }

    /**
     * Ensure that the component of color does not exceed 1 during the animation
     *
     * @param color
     *        the color we are checking
     * @return true if that component exceeds 1
     */
    private static boolean isExceedMaximumColor(float color) {
        return (DELTA * ITERATIONS_FLASH + color) >= 1;
    }

    /**
     * gets a color as a fraction over 255
     *
     * @param color
     *        is the int we are converting to a fractional float
     * @return the float of the color
     */
    private static float getColorAsFloat(int color) {
        return color / MAX_COLOR;
    }

    /**
     * sets the color of the component
     *
     * @param color
     *        the color to be set to
     */
    private static void setColor(Color color) {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                _component.setColor(color);
            }
        });
    }

    /**
     * Wait DELAY miliseconds before the next action
     */
    private static void waitAWhile() {
        try {
            Thread.sleep(DELAY);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\look\UIAnimator.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\look\UIHelper.java
	 */


package bakatxt.gui.look;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.geom.RoundRectangle2D;

/**
 * Helper methods and variables for the GUI, mostly for shaping, locations and sizes
 *
 */
public class UIHelper {
    /**
     * Get the size of the screen BakaTxt is on
     */
    public static final Dimension SCREEN_SIZE = Toolkit.getDefaultToolkit()
                                                .getScreenSize();

    /**
     * The location of BakaTxt relative to the top of the screen
     */
    public static final int WINDOW_OFFSET_TOP = SCREEN_SIZE.height/6;

    /**
     * The width of BakaTxt
     */
    public static final int WINDOW_X = 650;

    /**
     * The height of BakaTxt
     */
    public static final int WINDOW_Y = SCREEN_SIZE.height - 2 * WINDOW_OFFSET_TOP;

    /**
     * The width and height of BakaTxt as a Dimension object
     */
    public static final Dimension WINDOW_SIZE = new Dimension(WINDOW_X, WINDOW_Y);

    /**
     * The location of BakaTxt on the screen
     */
    public static final Point WINDOW_LOCATION = new Point(SCREEN_SIZE.width / 2 -
                                                          WINDOW_X / 2,
                                                          WINDOW_OFFSET_TOP);

    /**
     * Standard roundedness variable used for most rounded corners in BakaTxt
     */
    public static final int WINDOW_ROUNDNESS = 20;

    /**
     * Standard (half of) width variable used for borders in BakaTxt
     */
    public static final int BORDER = 4;

    /**
     * Location of the input box in BakaTxt
     */
    public static final Point INPUT_LOCATION = new Point(BORDER * 2, BORDER * 2);

    /**
     * A transparent color
     */
    public static final Color TRANSPARENT = new Color(0, 0, 0, 0);

    /**
     * Size of a taskbox
     */
    public static final Dimension TASKBOX_SIZE = new Dimension(WINDOW_X -
                                                                  4 * BORDER,
                                                                  100);

    /**
     * Draw a rectangle with rounded edges
     *
     * @param g
     *        abstract base class for all graphics contexts
     * @param background
     *        color to paint
     * @param width
     *        width of component
     * @param height
     *        height of component
     */
    public static void paintRoundedRectangle(Graphics g, Color background,
                                                int width, int height) {
        paintRoundedRectangle(g, background, 0, 0, width, height, WINDOW_ROUNDNESS);
    }

    /**
     * Draw a rectangle with rounded edges with roundness specification
     *
     * @param g
     *        abstract base class for all graphics contexts
     * @param background
     *        color to paint
     * @param startX
     *        start X location to paint the rectangle
     * @param startY
     *        start Y location to paint the rectangle
     * @param width
     *        width of component
     * @param height
     *        height of component
     * @param round
     *        specify the radius of the round corners
     */
    public static void paintRoundedRectangle(Graphics g, Color background,
                                                int startX, int startY,
                                                int width, int height, int round) {
        Graphics2D g2d = (Graphics2D) g.create();
        g2d.setRenderingHints(UIHelper.antiAlias());
        g2d.setColor(background);
        g2d.fill(new RoundRectangle2D.Double(startX, startY, width, height,
                                             round, round));
        g2d.dispose();
    }

    /**
     * Provide RenderingHints for anti-aliasing
     *
     * @return RenderingHints for anti-aliasing
     */
    public static RenderingHints antiAlias() {
        RenderingHints qualityHints =
                new RenderingHints(RenderingHints.KEY_ANTIALIASING,
                                   RenderingHints.VALUE_ANTIALIAS_ON);
        qualityHints.put(
                RenderingHints.KEY_RENDERING,
                RenderingHints.VALUE_RENDER_QUALITY);

        return qualityHints;
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\look\UIHelper.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\MiddleTaskBox.java
	 */


package bakatxt.gui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;

import bakatxt.core.Task;

/**
 * This class dictates the color and shape of the box which the task will be put in.
 * This box is specifically for a box in the middle.
 *
 */
final class MiddleTaskBox extends TaskBox {

    public MiddleTaskBox(Task task, int index, Color backgroundColor) {
        super(task, index, backgroundColor);
    }

    @Override
    protected void paintComponent(Graphics g) {
        Graphics2D g2d = (Graphics2D) g.create();
        g2d.setColor(getBackground());
        g2d.fill(new Rectangle2D.Double(0, 0, getWidth(), getHeight()));
        g2d.dispose();
        super.paintComponent(g);
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\MiddleTaskBox.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\OnlyTaskBox.java
	 */


package bakatxt.gui;

import java.awt.Color;
import java.awt.Graphics;

import bakatxt.core.Task;
import bakatxt.gui.look.UIHelper;

/**
 * This class dictates the color and shape of the box which the task will be put in.
 * This box is specifically for box that is by itself.
 *
 */
final class OnlyTaskBox extends TaskBox {

    public OnlyTaskBox(Task task, int index, Color backgroundColor) {
        super(task, index, backgroundColor);
    }

    @Override
    protected void paintComponent(Graphics g) {
        UIHelper.paintRoundedRectangle(g, getBackground(), getWidth(), getHeight());
        super.paintComponent(g);
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\OnlyTaskBox.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\gui\TaskBox.java
	 */


package bakatxt.gui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Point;

import javax.swing.JPanel;

import bakatxt.core.Task;
import bakatxt.gui.look.BakaAnimator;
import bakatxt.gui.look.ThemeReader;
import bakatxt.gui.look.UIHelper;

/**
 * This class places the elements of a single task correctly in their box.
 *
 */
abstract class TaskBox extends JPanel implements BakaAnimator {

    protected static final boolean IS_LINE_WRAP = true;
    private static final String AT = " @";

    private static final String DONE = "âœ“";
    private static final String UNDONE = "âœ—";
    private static final String OVERDUE = UNDONE + "!";

    private final Color _baseColor;

    public TaskBox(Task task, int index, Color backgroundColor) {

        setOpaque(false);
        setBackground(backgroundColor);
        setLayout(new GridBagLayout());
        addComponentsToPane(task, index);

        _baseColor = backgroundColor;
    }

    /**
     * Draws the various components in a taskbox
     *
     * @param task
     *        is the task to draw on the taskbox
     * @param index is the position within bakatxt where the taskbox
     */
    protected void addComponentsToPane(Task task, int index) {
        GridBagConstraints layout = new GridBagConstraints();

        setNumber(layout, index);
        setTaskAndLocation(layout, task.getTitle(), task.getVenue());
        setTimeStart(layout, task.getTime());
        setDescription(layout, task.getDescription());
        setTaskCompletionState(layout, doneState(task));
        setTimeEnd(layout, task.getEndTime());
    }

    /**
     * draw the index number of the task
     *
     * @param layout
     *        the layout we are drawing the string on
     * @param number
     *        is the number we are writing
     */
    private void setNumber(GridBagConstraints layout, int number) {

        FormattedText index = new FormattedText(shouldAddLeadingZero(number),
                                                ThemeReader.getNumberTheme());
        layout.fill = GridBagConstraints.NONE;
        layout.anchor = GridBagConstraints.LAST_LINE_START;
        layout.weightx = 1.0;
        layout.weighty = 0.0;
        layout.gridx = 0;
        layout.gridy = 0;
        layout.gridwidth = 1;
        layout.gridheight = 1;
        layout.insets = new Insets(0, 2 * UIHelper.BORDER, 0, 0);
        this.add(index, layout);
    }

    // TODO make locationText a different color
    /**
     * draw the task name and the location name of the task
     *
     * @param layout
     *        the layout we are drawing the string on
     * @param taskText
     *        the task name we are writing
     * @param locationText
     *        the location name we are writing
     */
    private void setTaskAndLocation(GridBagConstraints layout, String taskText,
                                    String locationText) {
        locationText = removeNullValues(AT, locationText);
        FormattedText task = new FormattedText(taskText + locationText,
                                               ThemeReader.getTitleTheme(),
                                               IS_LINE_WRAP);
        layout.fill = GridBagConstraints.HORIZONTAL;
        layout.anchor = GridBagConstraints.LAST_LINE_START;
        layout.weightx = 0.01;
        layout.weighty = 0.0;
        layout.gridx = 1;
        layout.gridy = 0;
        layout.gridwidth = 1;
        layout.gridheight = 1;
        layout.insets = new Insets(0, 5 * UIHelper.BORDER, 0, 0);
        this.add(task, layout);
    }

    /**
     * draw the description of the task
     *
     * @param layout
     *        the layout we are drawing the string on
     * @param descriptionText
     *        the description of the task we are writing
     */
    private void setDescription(GridBagConstraints layout, String descriptionText) {
        FormattedText description = new FormattedText(descriptionText,
                                                      ThemeReader.getDefaultTheme(),
                                                      IS_LINE_WRAP);
        layout.fill = GridBagConstraints.BOTH;
        layout.anchor = GridBagConstraints.FIRST_LINE_START;
        layout.weightx = 1.0;
        layout.weighty = 1.0;
        layout.gridx = 1;
        layout.gridy = 1;
        layout.gridwidth = 1;
        layout.gridheight = 1;
        layout.insets = new Insets(2 * UIHelper.BORDER, 5 * UIHelper.BORDER, 0, 0);
        this.add(description, layout);
    }

    /**
     * draw the starting time of the task
     *
     * @param layout
     *        the layout we are drawing the string on
     * @param startTimeText
     *        the start time of the task we are writing
     */
    private void setTimeStart(GridBagConstraints layout, String startTimeText) {

        startTimeText = removeNullValues(startTimeText);
        FormattedText time = new FormattedText(startTimeText,
                                               ThemeReader.getDateTheme());
        layout.fill = GridBagConstraints.NONE;
        layout.anchor = GridBagConstraints.FIRST_LINE_END;
        layout.weightx = 0.01;
        layout.weighty = 0.1;
        layout.gridx = 2;
        layout.gridy = 0;
        layout.gridwidth = 1;
        layout.gridheight = 1;
        layout.insets = new Insets(3 * UIHelper.BORDER, 0, 0,
                                   2 * UIHelper.BORDER);
        this.add(time, layout);
    }

    /**
     * draw whether or not the task has been completed
     *
     * @param layout
     *        the layout we are drawing the string on
     * @param state
     *        is the task completion state
     */
    private void setTaskCompletionState(GridBagConstraints layout, String state) {
        FormattedText completionState = new FormattedText(state,
                                                          ThemeReader.getLocationTheme());
        layout.fill = GridBagConstraints.NONE;
        layout.anchor = GridBagConstraints.PAGE_START;
        layout.weightx = 0.01;
        layout.weighty = 1.0;
        layout.gridx = 0;
        layout.gridy = 1;
        layout.gridwidth = 1;
        layout.gridheight = 1;
        layout.insets = new Insets(2 * UIHelper.BORDER, 2 * UIHelper.BORDER,
                                   0, 0);
        this.add(completionState, layout);
    }

    /**
     * draw the end time of the task
     *
     * @param layout
     *        the layout we are drawing the string on
     * @param endTimeText
     *        is the end time we are writing
     */
    private void setTimeEnd(GridBagConstraints layout, String endTimeText) {

        endTimeText = removeNullValues(endTimeText);
        FormattedText time = new FormattedText(endTimeText,
                                               ThemeReader.getDateTheme());
        layout.fill = GridBagConstraints.NONE;
        layout.anchor = GridBagConstraints.LAST_LINE_END;
        layout.weightx = 0.01;
        layout.weighty = 1.0;
        layout.gridx = 2;
        layout.gridy = 1;
        layout.gridwidth = 1;
        layout.gridheight = 1;
        layout.insets = new Insets(0, 0, 3 * UIHelper.BORDER,
                                   2 * UIHelper.BORDER);
        this.add(time, layout);
    }

    /**
     * if present, remove null || "null"  and return an empty string. else return
     * the old string.
     *
     * @param s
     *        the string to check
     * @return the string after processing
     */
    private static String removeNullValues(String s) {
        if (isStringNull(s)) {
            return "";
        }
        return s;
    }

    /**
     * if present, remove null || "null"  and return an empty string. else return
     * the old string with a prefix.
     *
     * @param prefix
     *        the prefix to append
     * @param s
     *        the string to check
     * @return the string after processing
     */
    private static String removeNullValues(String prefix, String s) {
        if (isStringNull(s)) {
            return "";
        }
        return prefix + s;
    }

    /**
     * Add a leading zero for numbers less than 10
     *
     * @param number
     *        the number to add the leading zero
     * @return the number with the leading zero as a string
     */
    private static String shouldAddLeadingZero(int number) {
        String num = Integer.toString(number);
        if (number < 10) {
            num = "0" + num;
        }
        return num;
    }

    /**
     * check if a string is null or "null"
     *
     * @param s
     *        the string to check
     * @return true if the string is either null value
     */
    private static boolean isStringNull(String s) {
        return (s == null || s.equals("null"));
    }

    /**
     * check the done state of the task and returns the appropriate string to
     * show the user
     *
     * @param task
     *        is the task to check the done state
     * @return a nice looking string to reflect that
     */
    private static String doneState(Task task) {
        if (task.isDone()) {
            return DONE;
        } else if (task.isOverdue()) {
            return OVERDUE;
        }
        return UNDONE;
    }

    /**
     * border is transparent
     */
    @Override
    protected void paintBorder(Graphics g) {
        g.setColor(UIHelper.TRANSPARENT);
    }

    // TODO does not work yet
    /**
     * @see {@link bakatxt.gui.look.BakaAnimator}
     */
    @Override
    public Color getColor() {
        return _baseColor;
    }

    /**
     * @see {@link bakatxt.gui.look.BakaAnimator}
     */
    @Override
    public void setColor(Color newColor) {
        setBackground(newColor);
    }

    /**
     * We are not animating the location for TaskBox
     */
    @Override
    public Point getPoint() {
        return null;
    }

    @Override
    public void setPoint(Point newLocation) {
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\gui\TaskBox.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\test\BakaBot.java
	 */


package bakatxt.test;

import static java.awt.event.KeyEvent.*;

import java.awt.AWTException;
import java.awt.Robot;
import java.awt.event.InputEvent;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import bakatxt.core.BakaProcessor;
import bakatxt.gui.BakaUI;
import bakatxt.gui.look.UIHelper;

/**
 * This class is a helper class to automate test cases for JUnit on the GUI.
 *
 */
public class BakaBot extends Robot {

    /**
     * places to store and backup our test files
     */
    private static final Path TEST_FILE = new File("./BakaStorage.txt").toPath();
    private static final Path TEST_FILE_SAVE = new File("./BakaStorage.txt.bak").toPath();

    /**
     * commands
     */
    public static final String ADD = "add ";
    public static final String DELETE = "delete ";
    public static final String REMOVE = "remove ";
    public static final String EDIT = "edit ";
    public static final String DISPLAY = "display ";
    public static final String SHOW = "show ";
    public static final String VIEW = "view ";
    public static final String CLEAR = "clear";
    public static final String UNDO = "undo";
    public static final String REDO = "redo";
    public static final String SEARCH = "search ";
    public static final String DONE = "done ";

    /**
     * delay between events
     */
    public static final int WAIT_SHORT = 25;
    public static final int WAIT_MEDIUM = 100;
    public static final int WAIT_LONG = 500;
    public static final int WAIT_VERY_LONG = 1500;

    /**
     * sample strings
     */
    public static final String SAMPLE_FOX = "the quick brown fox jumps over "
                                          + "the lazy dog 1234567890";
    public static final String SAMPLE_ZOMBIES = "PAINFUL ZOMBIES QUICKLY WATCH A"
                                                + "JINXED GRAVEYARD";

    public BakaBot() throws AWTException {
        super();
    }

    /**
     * Call this in the @BeforeClass method in your JUnit test. Sets up the files
     * for testing while retaining the old files.
     *
     * @throws IOException
     */
    public static void botOneTimeSetUp() throws IOException {
        saveOldFile();
        initializeTestFile();
        BakaUI.startGui(new BakaProcessor(true));
    }

    /**
     * Call this in the @AfterClass method in your JUnit test. Restores the old
     * task database file used before the test.
     *
     * @throws IOException
     */
    public static void botOneTimeTearDown() throws IOException {
        restoreTestFile();
    }

    /**
     * Call this in the @Before method in your JUnit test. Does nothing currently.
     */
    public static void botSetUp(){
    }

    /**
     * Call this in the @After method in your JUnit test. Pauses for 2 seconds
     * between each test to prevent interference between each test.
     */
    public static void botTearDown() {
        waitAWhile(WAIT_LONG);
    }

    /**
     * moves the cursor to the input box and simulate a keyboard typing the
     * string s
     *
     * @param s
     *        the string to be typed
     */
    public void inputThisString(String s) {
        typeThis(s);
        waitAWhile(WAIT_SHORT);
        enter();
    }

    /**
     * moves the cursor to the BakaTxt input box and clicks it
     *
     * @deprecated this method is no longer needed since the input box is auto
     * selected on initiation
     */
    @Deprecated
    public void mouseToInputBox() {
        mouseMove(UIHelper.WINDOW_LOCATION.x + 60,
                UIHelper.WINDOW_LOCATION.y + 20);
        mousePress(InputEvent.BUTTON1_DOWN_MASK);
        waitAWhile(WAIT_SHORT);
        mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
    }

    /**
     * Tells the process to wait waitTime milliseconds
     *
     * @param waitTime is the time in miliseconds to wait
     */
    public static void waitAWhile(final int waitTime) {
        try {
            Thread.sleep(waitTime);
        } catch (InterruptedException e) {
        }
    }

    /**
     * Simulates an enter key being pressed
     */
    public void enter() {
        typeThis("\n");
    }

    /**
     * Types a string using keyboard inputs
     *
     * @param toBeTyped
     *        the string to be typed
     */
    public void typeThis(CharSequence toBeTyped) {
        for (int i = 0; i < toBeTyped.length(); i++) {
            char character = toBeTyped.charAt(i);
            typeThisChar(character);
            waitAWhile(WAIT_SHORT);
        }
    }

    /**
     * Saves the current database otherwise it would be written with the test cases
     *
     * @throws IOException
     */
    private static void saveOldFile() throws IOException {
        Files.deleteIfExists(TEST_FILE_SAVE);
        if (Files.exists(TEST_FILE)) {
            Files.copy(TEST_FILE, TEST_FILE_SAVE);
        }
    }

    /**
     * Initializes a new database, this is actually unnecessary.
     *
     * @throws IOException
     */
    private static void initializeTestFile() throws IOException {
        Files.deleteIfExists(TEST_FILE);
        Files.createFile(TEST_FILE);
    }

    /**
     * Restores the old database.
     *
     * @throws IOException
     */
    private static void restoreTestFile() throws IOException {
        Files.deleteIfExists(TEST_FILE);
        if (Files.exists(TEST_FILE_SAVE)) {
            Files.copy(TEST_FILE_SAVE, TEST_FILE);
        }
        Files.deleteIfExists(TEST_FILE_SAVE);
    }

    /**
     * types a character, note, only what is on a standard keyboard layout,
     * i.e, no unicode
     *
     * @param character
     *        is the character to be typed
     */
    private void typeThisChar(char character) {
        switch (character) {
            case 'a' :
                typingThisChar(VK_A);
                break;
            case 'b' :
                typingThisChar(VK_B);
                break;
            case 'c' :
                typingThisChar(VK_C);
                break;
            case 'd' :
                typingThisChar(VK_D);
                break;
            case 'e' :
                typingThisChar(VK_E);
                break;
            case 'f' :
                typingThisChar(VK_F);
                break;
            case 'g' :
                typingThisChar(VK_G);
                break;
            case 'h' :
                typingThisChar(VK_H);
                break;
            case 'i' :
                typingThisChar(VK_I);
                break;
            case 'j' :
                typingThisChar(VK_J);
                break;
            case 'k' :
                typingThisChar(VK_K);
                break;
            case 'l' :
                typingThisChar(VK_L);
                break;
            case 'm' :
                typingThisChar(VK_M);
                break;
            case 'n' :
                typingThisChar(VK_N);
                break;
            case 'o' :
                typingThisChar(VK_O);
                break;
            case 'p' :
                typingThisChar(VK_P);
                break;
            case 'q' :
                typingThisChar(VK_Q);
                break;
            case 'r' :
                typingThisChar(VK_R);
                break;
            case 's' :
                typingThisChar(VK_S);
                break;
            case 't' :
                typingThisChar(VK_T);
                break;
            case 'u' :
                typingThisChar(VK_U);
                break;
            case 'v' :
                typingThisChar(VK_V);
                break;
            case 'w' :
                typingThisChar(VK_W);
                break;
            case 'x' :
                typingThisChar(VK_X);
                break;
            case 'y' :
                typingThisChar(VK_Y);
                break;
            case 'z' :
                typingThisChar(VK_Z);
                break;
            case 'A' :
                typingThisChar(VK_SHIFT, VK_A);
                break;
            case 'B' :
                typingThisChar(VK_SHIFT, VK_B);
                break;
            case 'C' :
                typingThisChar(VK_SHIFT, VK_C);
                break;
            case 'D' :
                typingThisChar(VK_SHIFT, VK_D);
                break;
            case 'E' :
                typingThisChar(VK_SHIFT, VK_E);
                break;
            case 'F' :
                typingThisChar(VK_SHIFT, VK_F);
                break;
            case 'G' :
                typingThisChar(VK_SHIFT, VK_G);
                break;
            case 'H' :
                typingThisChar(VK_SHIFT, VK_H);
                break;
            case 'I' :
                typingThisChar(VK_SHIFT, VK_I);
                break;
            case 'J' :
                typingThisChar(VK_SHIFT, VK_J);
                break;
            case 'K' :
                typingThisChar(VK_SHIFT, VK_K);
                break;
            case 'L' :
                typingThisChar(VK_SHIFT, VK_L);
                break;
            case 'M' :
                typingThisChar(VK_SHIFT, VK_M);
                break;
            case 'N' :
                typingThisChar(VK_SHIFT, VK_N);
                break;
            case 'O' :
                typingThisChar(VK_SHIFT, VK_O);
                break;
            case 'P' :
                typingThisChar(VK_SHIFT, VK_P);
                break;
            case 'Q' :
                typingThisChar(VK_SHIFT, VK_Q);
                break;
            case 'R' :
                typingThisChar(VK_SHIFT, VK_R);
                break;
            case 'S' :
                typingThisChar(VK_SHIFT, VK_S);
                break;
            case 'T' :
                typingThisChar(VK_SHIFT, VK_T);
                break;
            case 'U' :
                typingThisChar(VK_SHIFT, VK_U);
                break;
            case 'V' :
                typingThisChar(VK_SHIFT, VK_V);
                break;
            case 'W' :
                typingThisChar(VK_SHIFT, VK_W);
                break;
            case 'X' :
                typingThisChar(VK_SHIFT, VK_X);
                break;
            case 'Y' :
                typingThisChar(VK_SHIFT, VK_Y);
                break;
            case 'Z' :
                typingThisChar(VK_SHIFT, VK_Z);
                break;
            case '0' :
                typingThisChar(VK_0);
                break;
            case '1' :
                typingThisChar(VK_1);
                break;
            case '2' :
                typingThisChar(VK_2);
                break;
            case '3' :
                typingThisChar(VK_3);
                break;
            case '4' :
                typingThisChar(VK_4);
                break;
            case '5' :
                typingThisChar(VK_5);
                break;
            case '6' :
                typingThisChar(VK_6);
                break;
            case '7' :
                typingThisChar(VK_7);
                break;
            case '8' :
                typingThisChar(VK_8);
                break;
            case '9' :
                typingThisChar(VK_9);
                break;
            case '-' :
                typingThisChar(VK_MINUS);
                break;
            case '@' :
                typingThisChar(VK_SHIFT, VK_2);
                break;
            case '\n' :
                typingThisChar(VK_ENTER);
                break;
            case '/' :
                typingThisChar(VK_SLASH);
                break;
            case ' ' :
                typingThisChar(VK_SPACE);
                break;
            case ':' :
                typingThisChar(VK_SHIFT, VK_SEMICOLON);
                break;
            case '.' :
                typingThisChar(VK_PERIOD);
                break;
            default :
                throw new IllegalArgumentException("Cannot type: " + character);
        }
    }

    /**
     * Types the char based on what keypresses are needed to type it
     *
     * @param keyCodes
     *        the keyCodes needed to be activated
     */
    private void typingThisChar(int... keyCodes) {
        for (int i = 0; i < keyCodes.length; i++) {
            keyPress(keyCodes[i]);
        }
        waitAWhile(WAIT_SHORT);
        for (int i = 0; i < keyCodes.length; i++) {
            keyRelease(keyCodes[i]);
        }
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\test\BakaBot.java





	/**
	 * origin: U:\workspace\BakaTxt\src\bakatxt\test\UITest.java
	 */


package bakatxt.test;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

import java.awt.AWTException;
import java.awt.Color;
import java.awt.Point;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import bakatxt.gui.BakaUI;
import bakatxt.gui.look.UIHelper;

/**
 * This class is an automated test case for GUI elements
 *
 */
@SuppressWarnings("boxing")
public class UITest {

    /**
     *  _bot will help us automate typing & mouse movement
     */
    private static BakaBot _bot;

    @BeforeClass
    public static void oneTimeSetUp() throws Exception {
        _bot = new BakaBot();
        BakaBot.botOneTimeSetUp();
    }

    @AfterClass
    public static void oneTimeTearDown() throws Exception {
        BakaBot.botOneTimeTearDown();
    }

    @Before
    public void setUp() throws Exception {
        BakaBot.botSetUp();
    }

    @After
    public void tearDown() throws Exception {
        BakaBot.botTearDown();
    }

    /**
     * Ensure that the program is actually visible
     * Boundary case for the negative partition.
     *
     * @throws AWTException
     */
    @Test
    public void testMinHeightOfUIElements() throws AWTException {
        assertThat(BakaUI.getPanel().getHeight(), is(greaterThan(0)));
    }


    /**
     * Ensure that the program height is not too long.
     * Boundary case for the positive partition.
     *
     * @throws AWTException
     */
    @Test
    public void testMaxHeightOfUIElements() throws AWTException {
        showAllTasks();
        addALotOfTasks();
        assertThat(getScrollPaneHeight(), is(equalTo(UIHelper.WINDOW_Y)));
    }

    /**
     * Ensure that the width of the program does not change
     *
     * @throws AWTException
     */
    @Test
    public void testUnchangedWidth() throws AWTException {
        _bot.inputThisString(BakaBot.ADD + BakaBot.SAMPLE_FOX
                             + BakaBot.SAMPLE_ZOMBIES);
        BakaBot.waitAWhile(BakaBot.WAIT_LONG);
        assertThat(BakaUI.getPanel().getWidth(), is(equalTo(UIHelper.WINDOW_X)));
    }

    /**
     * The input box moves about a lot if the input fails, hence, we need to
     * ensure that it does not move out of position
     *
     * @throws AWTException
     */
    @Test
    public void testFailedInput() throws AWTException {
        _bot.inputThisString(BakaBot.ADD + BakaBot.ADD);
        spamEnter();
        BakaBot.waitAWhile(BakaBot.WAIT_VERY_LONG);
        assertThat(getInputBoxLocation(), is(equalTo(UIHelper.INPUT_LOCATION)));
    }

    /**
     * The input box changes color on successful input, we need to make sure that
     * the color returns to it's normal state upon animation completion
     *
     * @throws AWTException
     */
    @Test
    public void testSuccessfulInput() throws AWTException {
        showAllTasks();
        spamEnter();
        BakaBot.waitAWhile(BakaBot.WAIT_VERY_LONG);
        assertThat(getInputBoxColor(), is(equalTo(getProperInputBoxColor())));
    }

    /**
     * Types 'display ' and enter
     */
    private static void showAllTasks() {
        _bot.inputThisString(BakaBot.DISPLAY);
    }

    /**
     * Adds enough tasks such that the scroll bar 'appears'
     */
    private static void addALotOfTasks() {
        final int iterations = UIHelper.SCREEN_SIZE.height / 100;
        for (int i = 0; i < iterations; i++) {
            _bot.inputThisString(BakaBot.ADD + "some task" + i);
            BakaBot.waitAWhile(BakaBot.WAIT_MEDIUM);
        }
    }

    /**
     * Hits the enter key. A lot.
     */
    private static void spamEnter() {
        for (int i = 0; i < 100; i++) {
            _bot.enter();
        }
    }

    /**
     * @return the height of the scrollpane
     */
    private static int getScrollPaneHeight() {
        return BakaUI.getPanel().getScrollPane().getHeight();
    }

    /**
     * @return the relative location of the input box
     */
    private static Point getInputBoxLocation() {
        return BakaUI.getPanel().getInput().getLocation();
    }

    /**
     * @return the color of the input box
     */
    private static Color getInputBoxColor() {
        return BakaUI.getPanel().getInput().getBackground();
    }

    /**
     * @return the base color of the input box
     */
    private static Color getProperInputBoxColor() {
        return BakaUI.getPanel().getInput().getColor();
    }
}

	// End of segment: U:\workspace\BakaTxt\src\bakatxt\test\UITest.java





